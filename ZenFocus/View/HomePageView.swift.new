//
//  HomePageView.swift
//  ZenFocus
//
//  Created by Jayanta Adhikary on 11/06/25.
//

import SwiftUI
import AVFoundation
import SwiftData

struct HomePageView: View {
    @Environment(\.modelContext) private var modelContext
    @Query var allSessions: [FocusSession]
    @Query var userSettings: [UserSettings]
    @Query var focusTasks: [FocusTask]
    
    @StateObject private var audioManager = AmbientAudioManager.shared
    
    var sessionDays: [Date] {
        let calendar = Calendar.current
        let uniqueDays = Set(allSessions.map { calendar.startOfDay(for: $0.date) })
        return Array(uniqueDays).sorted(by: >)
    }
    
    var streak: Int {
        let calendar = Calendar.current
        var streakCount = 0
        var currentDate = calendar.startOfDay(for: Date())
        
        let sessionDaysSet = Set(sessionDays)
        
        while sessionDaysSet.contains(currentDate) {
            streakCount += 1
            currentDate = calendar.date(byAdding: .day, value: -1, to: currentDate)!
        }
        
        return streakCount
    }
    
    @State private var showAmbientPicker = false
    @State private var selectedAmbient: AmbientOption = ambientOptions[0]
    
    @State private var totalTime: Int = 0
    @State private var timeRemaining: Int = 0
    @State private var hasInitializedTime = false
    @State private var timeElapsed: Int = 0
    
    @State private var isPlaying: Bool = false
    @State private var isPaused: Bool = false
    @State private var pauseCount: Int = 0
    @State private var totalPausedTime: Int = 0
    @State private var lastPauseStartTime: Date? = nil
    
    @State private var hasCompletedSession = false
    @State private var showAmbientPickerWarning = false
    @State private var showTaskWarning = false
    @State private var showCompletionSheet = false
    @State private var showBreakReminder = false
    @State private var completedTaskName = ""
    @State private var completedDuration = 0
    
    @State private var selectedTask: FocusTask?
    
    var focusSessionsToday: Int {
        let startOfToday = Calendar.current.startOfDay(for: Date())
        return allSessions.filter { $0.date >= startOfToday }.count
    }
    
    private func resetTime() {
        timeRemaining = totalTime
        timeElapsed = 0
        isPlaying = false
        isPaused = false
        hasCompletedSession = false
        pauseCount = 0
        totalPausedTime = 0
        lastPauseStartTime = nil
        audioManager.stop()
        UIApplication.shared.isIdleTimerDisabled = false
        
        // Save pause state to UserDefaults
        UserDefaults.standard.setValue(false, forKey: "isSessionActive")
    }
    
    private func updateTimer() {
        // Handle countdown logic
        if isPlaying && !isPaused && timeRemaining > 0 {
            timeRemaining -= 1
            timeElapsed += 1
            
            // Save current state to UserDefaults for persistence
            UserDefaults.standard.setValue(timeRemaining, forKey: "timeRemaining")
            UserDefaults.standard.setValue(timeElapsed, forKey: "timeElapsed")
            UserDefaults.standard.setValue(true, forKey: "isSessionActive")
        }
        
        // Check for session completion
        checkSessionCompletion()
    }
    
    private func checkSessionCompletion() {
        // Only proceed if timer has reached zero and session is active
        if timeRemaining != 0 || !isPlaying || hasCompletedSession {
            return
        }
        
        // Mark session as complete
        hasCompletedSession = true
        isPlaying = false
        
        // Stop audio and play alert
        audioManager.stop()
        AudioServicesPlayAlertSound(1106)
        
        // Only save session if a task was selected
        if let task = selectedTask {
            saveCompletedSession(task: task)
        }
    }
    
    private func saveCompletedSession(task: FocusTask) {
        // Create and save the session with enhanced data
        let session = FocusSession(
            taskName: task.name,
            duration: totalTime,
            pauseCount: pauseCount,
            totalPausedTime: totalPausedTime,
            completionDate: Date()
        )
        modelContext.insert(session)
        try? modelContext.save()
        
        // Prepare completion sheet data
        completedTaskName = task.name
        completedDuration = totalTime
        showCompletionSheet = true
        
        // Clear session state from UserDefaults
        UserDefaults.standard.removeObject(forKey: "isSessionActive")
        UserDefaults.standard.removeObject(forKey: "timeRemaining")
        UserDefaults.standard.removeObject(forKey: "timeElapsed")
        UserDefaults.standard.removeObject(forKey: "isPaused")
        UserDefaults.standard.removeObject(forKey: "pauseStartTime")
    }
    
    let timer = Timer.publish(every: 1, on: .main, in: .common).autoconnect()
    
    var body: some View {
        NavigationStack {
            VStack {
                Spacer()
                
                Text("Focus â€¢ \(focusSessionsToday) of \(userSettings.first?.dailyTargetSessions ?? 4)")
                    .font(.subheadline)
                    .foregroundStyle(.secondary)
                    .animation(.easeInOut(duration: 0.3), value: focusSessionsToday)
                
                Spacer()
                
                if totalTime > 0 {
                    TimerView(
                        timeRemaining: timeRemaining, 
                        totalTime: totalTime,
                        isPaused: isPaused
                    )
                    .scaleEffect(isPlaying && !isPaused ? 1.02 : 1.0)
                    .animation(isPlaying && !isPaused ? 
                              .easeInOut(duration: 0.8).repeatForever(autoreverses: true) : 
                              .easeOut(duration: 0.3), 
                              value: isPlaying)
                    .id("timer-\(isPlaying ? "playing" : "stopped")-\(isPaused ? "paused" : "active")")
                    //MARK:- Remove the triple tap gesture for test mode
                    .onTapGesture(count: 3) {  // Triple tap to set 10-second test timer
                        totalTime = 10
                        timeRemaining = 10
                    }
                    // Indicate pause state with subtle animation
                    .overlay(
                        isPaused ? 
                            RoundedRectangle(cornerRadius: 130)
                                .stroke(Color.orange.opacity(0.2), lineWidth: 2)
                                .frame(width: 270, height: 270)
                            : nil
                    )
                }
                
                Spacer()
                
                Text("ðŸŽ¯ \(focusSessionsToday) focus session\(focusSessionsToday <= 1 ? "" : "s") completed today")
                    .font(.footnote)
                    .foregroundStyle(.secondary)
                    .contentTransition(.numericText())
                    .animation(.bouncy(duration: 0.6), value: focusSessionsToday)
                
                Spacer()
                
                HStack {
                    Button {
                        if selectedTask == nil {
                            showTaskWarning = true
                            DispatchQueue.main.asyncAfter(deadline: .now() + 2) {
                                showTaskWarning = false
                            }
                            return
                        }
                        
                        withAnimation(.spring(response: 0.4, dampingFraction: 0.8)) {
                            if !isPlaying {
                                // Start a new session
                                isPlaying = true
                                isPaused = false
                                hasCompletedSession = false
                                
                                // Track session state
                                UserDefaults.standard.setValue(true, forKey: "isSessionActive")
                                UserDefaults.standard.setValue(selectedTask?.id.uuidString, forKey: "activeTaskID")
                                UserDefaults.standard.setValue(totalTime, forKey: "sessionTotalTime")
                                UserDefaults.standard.setValue(timeRemaining, forKey: "timeRemaining")
                                
                                // Keep screen on during session
                                UIApplication.shared.isIdleTimerDisabled = true
                                
                                // Start ambient sound
                                if let sound = selectedAmbient.audioFileName {
                                    audioManager.playSound(named: sound)
                                }
                                
                                // Haptic feedback
                                let impact = UIImpactFeedbackGenerator(style: .medium)
                                impact.impactOccurred()
                            } else {
                                // Toggle pause state
                                isPaused.toggle()
                                
                                if isPaused {
                                    // Entering pause state
                                    pauseCount += 1
                                    lastPauseStartTime = Date()
                                    audioManager.pause()
                                    UIApplication.shared.isIdleTimerDisabled = false
                                    
                                    // Save state
                                    UserDefaults.standard.setValue(true, forKey: "isPaused")
                                    UserDefaults.standard.setValue(Date(), forKey: "pauseStartTime")
                                    
                                    // Haptic feedback
                                    let impact = UIImpactFeedbackGenerator(style: .soft)
                                    impact.impactOccurred()
                                } else {
                                    // Resuming from pause
                                    if let pauseStartTime = lastPauseStartTime {
                                        let pauseDuration = Int(Date().timeIntervalSince(pauseStartTime))
                                        totalPausedTime += pauseDuration
                                    }
                                    
                                    audioManager.resume()
                                    UIApplication.shared.isIdleTimerDisabled = true
                                    
                                    // Update state
                                    UserDefaults.standard.setValue(false, forKey: "isPaused")
                                    UserDefaults.standard.setValue(totalPausedTime, forKey: "totalPausedTime")
                                    UserDefaults.standard.setValue(pauseCount, forKey: "pauseCount")
                                    
                                    // Haptic feedback
                                    let impact = UIImpactFeedbackGenerator(style: .rigid)
                                    impact.impactOccurred()
                                }
                            }
                        }
                    } label: {
                        // Better button state representation
                        Group {
                            if !isPlaying {
                                Label("Start", systemImage: "play.fill")
                                    .font(.headline)
                            } else if isPaused {
                                Label("Resume", systemImage: "play.fill")
                                    .font(.headline)
                            } else {
                                Label("Pause", systemImage: "pause.fill")
                                    .font(.headline)
                            }
                        }
                        .contentTransition(.symbolEffect(.replace))
                    }
                    .foregroundStyle(isPaused ? .orange : (isPlaying ? .primary : .green))
                    .padding(.horizontal, 16)
                    .padding(.vertical, 10)
                    .background(
                        RoundedRectangle(cornerRadius: 10)
                            .fill(isPaused ? Color.orange.opacity(0.1) : 
                                 (isPlaying ? Color.secondary.opacity(0.1) : Color.green.opacity(0.1)))
                    )
                    .scaleEffect(selectedTask == nil ? 0.95 : 1.0)
                    .opacity(selectedTask == nil ? 0.6 : 1.0)
                    .animation(.easeInOut(duration: 0.2), value: selectedTask)
                    .animation(.easeInOut(duration: 0.2), value: isPaused)
                    .animation(.easeInOut(duration: 0.2), value: isPlaying)
                    
                    Button {
                        withAnimation(.spring(response: 0.3, dampingFraction: 0.7)) {
                            resetTime()
                        }
                    } label: {
                        Image(systemName: "arrow.trianglepath")
                            .font(.title2)
                        Text("Reset")
                    }
                    .foregroundStyle(.primary)
                    .padding(.horizontal)
                }
                
                Spacer()

                VStack {
                    Text("What are you focusing on?")
                        .font(.headline)
                        .foregroundStyle(.secondary)

                    ScrollView(.horizontal, showsIndicators: false) {
                        HStack {
                            ForEach(focusTasks) { item in
                                Button {
                                    if !isPlaying {
                                        withAnimation(.spring(response: 0.3, dampingFraction: 0.6)) {
                                            selectedTask = selectedTask == item ? nil : item
                                        }
                                    }
                                } label: {
                                    HStack {
                                        Image(systemName: item.icon)
                                            .font(.body)
                                            .frame(width: 24)
                                        Text(item.name)
                                    }
                                    .padding(.vertical, 8)
                                    .padding(.horizontal, 12)
                                    .background(
                                        RoundedRectangle(cornerRadius: 8)
                                            .fill(selectedTask == item ? Color.accentColor : Color(.systemGray6))
                                    )
                                    .foregroundColor(selectedTask == item ? .white : .primary)
                                }
                                .buttonStyle(.plain)
                                .opacity(isPlaying && selectedTask != item ? 0.4 : 1.0)
                                .scaleEffect(isPlaying && selectedTask != item ? 0.95 : 1.0)
                                .disabled(isPlaying)
                            }
                        }
                        .padding(.horizontal, 4)
                    }
                }
                .opacity(isPlaying ? 0.6 : 1.0)
                .animation(.easeInOut(duration: 0.3), value: isPlaying)

                
                Spacer()
                
                Text(""Do what you can, with what you have, where you are."")
                    .font(.footnote)
                    .italic()
                    .foregroundStyle(.secondary)
                    .multilineTextAlignment(.center)
                    .padding(.bottom)
            }
            .toolbar {
                ToolbarItem(placement: .topBarTrailing) {
                    Button {
                        print("Streak Button tapped")
                    } label: {
                        HStack {
                            Image(systemName: "flame.fill")
                                .foregroundStyle(streak > 0 ? .orange : .gray)
                            if streak > 1 {
                                Text("\(streak)")
                                    .font(.callout)
                                    .foregroundStyle(.orange)
                            }
                        }
                    }
                    .disabled(true)
                }
                ToolbarItem(placement: .topBarLeading) {
                    Button {
                        if isPlaying {
                            showAmbientPickerWarning = true
                            DispatchQueue.main.asyncAfter(deadline: .now() + 2) {
                                showAmbientPickerWarning = false
                            }
                        } else {
                            showAmbientPicker.toggle()
                        }
                    } label: {
                        Image(systemName: selectedAmbient.icon)
                        Text(selectedAmbient.name)
                    }
                    .foregroundStyle(isPlaying ? .gray : .primary)
                    .sheet(isPresented: $showAmbientPicker) {
                        AmbientSheet(selected: $selectedAmbient)
                            .presentationDragIndicator(.visible)
                    }
                }
            }
            .onReceive(timer) { _ in
                // Handle countdown logic
                updateTimer()
            }
            .onReceive(NotificationCenter.default.publisher(for: UIApplication.willResignActiveNotification)) { _ in
                if isPlaying && !isPaused {
                    // Auto-pause when app goes to background
                    isPaused = true
                    lastPauseStartTime = Date()
                    audioManager.pause()
                    
                    // Save current state for potential app termination
                    UserDefaults.standard.setValue(true, forKey: "isPaused")
                    UserDefaults.standard.setValue(Date(), forKey: "pauseStartTime")
                    UserDefaults.standard.setValue(timeRemaining, forKey: "timeRemaining")
                    UserDefaults.standard.setValue(timeElapsed, forKey: "timeElapsed")
                    UserDefaults.standard.setValue(true, forKey: "isSessionActive")
                    UserDefaults.standard.setValue(pauseCount, forKey: "pauseCount")
                    UserDefaults.standard.setValue(totalPausedTime, forKey: "totalPausedTime")
                }
            }
            .onReceive(NotificationCenter.default.publisher(for: UIApplication.didBecomeActiveNotification)) { _ in
                // Check if we should resume from saved state
                if UserDefaults.standard.bool(forKey: "isSessionActive") {
                    // If we have a saved pause state, update pause duration
                    if UserDefaults.standard.bool(forKey: "isPaused"), 
                       let pauseStartTime = UserDefaults.standard.object(forKey: "pauseStartTime") as? Date {
                        let pauseDuration = Int(Date().timeIntervalSince(pauseStartTime))
                        totalPausedTime += pauseDuration
                    }
                }
            }
            .overlay(
                VStack(spacing: 8) {
                    if showTaskWarning {
                        Text("Please select a focus task first.")
                            .font(.footnote)
                            .foregroundColor(.white)
                            .padding(.horizontal, 16)
                            .padding(.vertical, 10)
                            .background(.red.opacity(0.9))
                            .clipShape(Capsule())
                            .transition(.opacity.combined(with: .scale))
                    }
                    
                    if showAmbientPickerWarning {
                        Text("Stop the timer to change ambient sound.")
                            .font(.footnote)
                            .foregroundColor(.white)
                            .padding(.horizontal, 16)
                            .padding(.vertical, 10)
                            .background(.gray.opacity(0.9))
                            .clipShape(Capsule())
                            .transition(.opacity.combined(with: .scale))
                    }
                }
                    .padding(.bottom, 50),
                alignment: .top
            )
            .animation(.easeInOut, value: showTaskWarning || showAmbientPickerWarning)
            .sheet(isPresented: $showCompletionSheet, onDismiss: {
                // Called when sheet is dismissed
                resetTime()
                hasCompletedSession = false
            }) {
                SessionCompletionSheet(
                    taskName: completedTaskName,
                    duration: completedDuration,
                    streakCount: streak,
                    dailyCount: focusSessionsToday,
                    onBreakRequest: {
                        // Show break reminder sheet when requested
                        DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
                            showBreakReminder = true
                        }
                    }
                )
                .presentationDragIndicator(.visible)
            }
            .sheet(isPresented: $showBreakReminder) {
                BreakReminderView(showBreakTimer: $showBreakReminder)
                    .presentationDragIndicator(.visible)
            }
        }
        .padding(8)
        .onAppear {
            // Initialize settings if needed
            if userSettings.isEmpty {
                let settings = UserSettings(defaultFocusDuration: 600, dailyTargetSessions: 4)
                modelContext.insert(settings)
                try? modelContext.save()
                totalTime = settings.defaultFocusDuration
                timeRemaining = settings.defaultFocusDuration
            } else if let settings = userSettings.first {
                totalTime = settings.defaultFocusDuration
                timeRemaining = settings.defaultFocusDuration
            }
            
            // Create default tasks if needed
            if focusTasks.isEmpty {
                let defaultTasks = [
                    FocusTask(name: "Work", icon: "desktopcomputer"),
                    FocusTask(name: "Study", icon: "book"),
                    FocusTask(name: "Coding", icon: "apple.terminal"),
                    FocusTask(name: "Reading", icon: "book.closed")
                ]
                defaultTasks.forEach { modelContext.insert($0) }
                try? modelContext.save()
            }
            
            // Restore session state if app was closed/terminated during an active session
            if UserDefaults.standard.bool(forKey: "isSessionActive") {
                // Get saved values
                let savedTimeRemaining = UserDefaults.standard.integer(forKey: "timeRemaining")
                let savedTimeElapsed = UserDefaults.standard.integer(forKey: "timeElapsed")
                let savedPauseCount = UserDefaults.standard.integer(forKey: "pauseCount")
                let savedTotalPausedTime = UserDefaults.standard.integer(forKey: "totalPausedTime")
                let wasPaused = UserDefaults.standard.bool(forKey: "isPaused")
                let taskIDString = UserDefaults.standard.string(forKey: "activeTaskID")
                
                if savedTimeRemaining > 0, let taskIDString = taskIDString, 
                   let taskID = UUID(uuidString: taskIDString) {
                    // Find the matching task
                    if let task = focusTasks.first(where: { $0.id == taskID }) {
                        // Restore task selection
                        selectedTask = task
                        
                        // Restore timer state
                        timeRemaining = savedTimeRemaining
                        timeElapsed = savedTimeElapsed
                        pauseCount = savedPauseCount
                        totalPausedTime = savedTotalPausedTime
                        
                        // Set state but don't auto-resume
                        isPlaying = true
                        isPaused = true // Always start paused when restored
                        
                        // Show restoration alert
                        DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
                            let generator = UINotificationFeedbackGenerator()
                            generator.notificationOccurred(.warning)
                            
                            // Show session restoration alert
                            let minutes = savedTimeRemaining / 60
                            let seconds = savedTimeRemaining % 60
                            let timeText = String(format: "%d:%02d", minutes, seconds)
                            
                            // This would be a more elegant solution with a custom alert,
                            // but for now we'll use the warning system
                            showTaskWarning = false
                            showAmbientPickerWarning = true
                            DispatchQueue.main.asyncAfter(deadline: .now() + 3) {
                                showAmbientPickerWarning = false
                            }
                        }
                    }
                }
            }
        }
        .onChange(of: userSettings.first?.defaultFocusDuration) { oldValue, newValue in
            if !isPlaying, let newVal = newValue {
                totalTime = newVal
                timeRemaining = newVal
            }
        }
        .onDisappear {
            resetTime()
        }
    }
}

#Preview("Light") {
    let container = try! ModelContainer(for: UserSettings.self, configurations: ModelConfiguration(isStoredInMemoryOnly: true))
    
    // Insert a mock user settings object
    let context = container.mainContext
    context.insert(UserSettings(defaultFocusDuration: 600, dailyTargetSessions: 5))
    
    return HomePageView()
        .modelContainer(container)
        .preferredColorScheme(.light)
}

#Preview("Dark") {
    let container = try! ModelContainer(for: UserSettings.self, configurations: ModelConfiguration(isStoredInMemoryOnly: true))
    
    let context = container.mainContext
    context.insert(UserSettings(defaultFocusDuration: 500, dailyTargetSessions: 4))
    
    return HomePageView()
        .modelContainer(container)
        .preferredColorScheme(.dark)
}
